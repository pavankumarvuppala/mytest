What is externalizable interface? 
Externalizable interface in Java
Externalization serves the purpose of custom Serialization, where we can decide what to store in stream.

Externalizable interface present in java.io, is used for Externalization which extends Serializable interface. It consist of two methods which we have to override to write/read object into/from stream which are-

// to read object from stream
void readExternal(ObjectInput in) 

// to write object into stream
void writeExternal(ObjectOutput out) 

Key differences between Serializable and Externalizable

Implementation : Unlike Serializable interface which will serialize the variables in object with just by implementing interface, here we have to explicitly mention what fields or variables you want to serialize.
Methods : Serializable is marker interface without any methods. Externalizable interface contains two methods: writeExternal() and readExternal().
Process: Default Serialization process will take place for classes implementing Serializable interface. Programmer defined Serialization process for classes implementing Externalizable interface.
Backward Compatibility and Control: If you have to support multiple versions, you can have full control with Externalizable interface. You can support different versions of your object. If you implement Externalizable, it’s your responsibility to serialize super class.
public No-arg constructor: Serializable uses reflection to construct object and does not require no arg constructor. But Externalizable requires public no-arg constructor.
================================================================================================================================================================================================================================
Transient key word?

transient is a Java keyword which marks a member variable not to be serialized when it is persisted to streams of bytes. When an object is transferred through the network, the object needs to be 'serialized'. Serialization converts the object state to serial bytes.
================================================================================================================================================================================================================================
Class level lock?

Class level lock is achieved by keyword "Static Synchronized,where as object level is achieved only by synchronized keyword. Object level lock is achieved to restrict same object to operate through different thread,where as class level lock is achieved to restrict any object to operate.


================================================================================================================================================================================================================================
Question on serialization
================================================================================================================================================================================================================================
Types of statements in jdbc?

Statement	Use this for general-purpose access to your database. Useful when you are using static SQL statements at runtime. The Statement interface cannot accept parameters.
PreparedStatement	Use this when you plan to use the SQL statements many times. The PreparedStatement interface accepts input parameters at runtime.
CallableStatement	Use this when you want to access the database stored procedures. The CallableStatement interface can also accept runtime input parameters.
================================================================================================================================================================================================================================

What is the difference between Statement and PreparedStatement?
Statement
- The parameter value is fixed
- Compiles and executes every time

PreparedStatement
- The parameter can be supplied at run time
- Precompiled ( compiled once ) and executes once for n number of parameter values.
================================================================================================================================================================================================================================
benifit of prepared statements

PreparedStatement objects are used to execute repetitive SQL statements. Compared to Statement object execution, Prepared Statement object creation is faster. The reason is the object is pre compiled, by eliminating the compilation task by DBMS. The PreparedStatement object can be used by just replacing the parameters.

Precompilation and DB-side caching of the SQL statement leads to overall faster execution and the ability to reuse the same SQL statement in batches.

Automatic prevention of SQL injection attacks by builtin escaping of quotes and other special characters. Note that this requires that you use any of the PreparedStatement setXxx() methods to set the values

Eases setting of non-standard Java objects in a SQL string, e.g. Date, Time, Timestamp, BigDecimal, InputStream (Blob) and Reader (Clob). On most of those types you can't "just" do a toString() as you would do in a simple Statement. You could even refactor it all to using PreparedStatement#setObject() inside a loop as demonstrated in the utility method below:

public static void setValues(PreparedStatement preparedStatement, Object... values) throws SQLException {
    for (int i = 0; i < values.length; i++) {
        preparedStatement.setObject(i + 1, values[i]);
    }
}
================================================================================================================================================================================================================================
What are sequences in oracle?

Sequence is a feature supported by some database systems to produce unique values on demand. Some DBMS like MySQL supports AUTO_INCREMENT in place of Sequence. AUTO_INCREMENT is applied on columns, it automatically increments the column value by 1 each time a new record is inserted into the table.
================================================================================================================================================================================================================================
left outer join and right join

Simple Example: Lets say you have a Students table, and a Lockers table. In SQL, the first table you specify in a join, Students, is the LEFT table, and the second one, Lockers, is the RIGHT table.

Each student can be assigned to a locker, so there is a LockerNumber column in the Student table. More than one student could potentially be in a single locker, but especially at the beginning of the school year, you may have some incoming students without lockers and some lockers that have no students assigned.

For the sake of this example, lets say you have 100 students, 70 of which have lockers. You have a total of 50 lockers, 40 of which have at least 1 student and 10 lockers have no student.

INNER JOIN is equivalent to "show me all students with lockers".
Any students without lockers, or any lockers without students are missing.
Returns 70 rows

LEFT OUTER JOIN would be "show me all students, with their corresponding locker if they have one". 
This might be a general student list, or could be used to identify students with no locker. 
Returns 100 rows

RIGHT OUTER JOIN would be "show me all lockers, and the students assigned to them if there are any". 
This could be used to identify lockers that have no students assigned, or lockers that have too many students. 
Returns 80 rows (list of 70 students in the 40 lockers, plus the 10 lockers with no student)

FULL OUTER JOIN would be silly and probably not much use. 
Something like "show me all students and all lockers, and match them up where you can" 
Returns 110 rows (all 100 students, including those without lockers. Plus the 10 lockers with no student)

CROSS JOIN is also fairly silly in this scenario.
It doesn't use the linked lockernumber field in the students table, so you basically end up with a big giant list of every possible student-to-locker pairing, whether or not it actually exists.
Returns 5000 rows (100 students x 50 lockers). Could be useful (with filtering) as a starting point to match up the new students with the empty lockers.


================================================================================================================================================================================================================================
What is webservice and how is it differ from web application? -- DONE
Web applications are defined by being interactive. You're supposed to use a web application in order to perform a function and use some of the web applications features. Lots of web applications don't even have real informative content or data exactly. People are just supposed to use them in order to perform additional tasks, using their features to accomplish something. You use a web application to check your incoming messages, for instance, or play a game.


Web service is a technology by which two or more remote web applications interact with each other over network/internet. It can be implemented using Java, .net, PHP etc. Web pages allow people to communicate and collaborate with each other while web services allow programs to communicate and collaborate with each other.
A web service is essentially a collection of open protocols and standards used for exchanging data between applications or systems. Software applications written in various programming languages and running on various platforms can use web services to exchange data over computer networks like the Internet in a manner similar to inter-process communication on a single computer. This interoperability (e.g., between Java and Python, or Windows and Linux applications) is due to the use of open standards (XML, SOAP, HTTP).


Web Application

A web application is a software application that a user runs in the web browser. It have the following features.

It has a User Interface
Runs in Client - Server environment
Client runs it with the help of a web browser
Server process the data based on client request and provide response
Web Service

A web service is an Application Program Interface (API) that runs on the server, which provide data to the client over http through a standardized messaging system. (XML, JSON, etc...). Web services are further classified into SOAP and REST. In the present day scenario most services prefer REST over SOAP.

Some other use cases of Web Services are

PayPal api
Facebook api
Twitter api
Conclusion

================================================================================================================================================================================================================================
Is SessionFactory thread safe?

Both Web Application and Web Service are a kind of same thing, but web application is for the users and Web Service is for Program <==> Program communication.

SessionFactory is Hibernates concept of a single datastore and is threadsafe so that many threads can access it concurrently and request for sessions and immutable cache of compiled mappings for a single database. A SessionFactory is usually only built once at startup. SessionFactory should be wrapped in some kind of singleton so that it can be easily accessed in an application code. 

SessionFactory sessionFactory = new Configuration().configure().buildSessionfactory();

What about session?

The Session  object was designed to be used by a single thread. Internally, the Session uses many non-thread-safe data structures so it’s impossible to make it thread-safe.
More, you shouldn’t even need to use a thread-safe Session . If your use case is to share the cached entities, then you should use the second-level cache instead which is thread-safe and can be used in a clustered environment.
That being said, the need for having a thread-safe Session is a code smell indicating a flaw in the design of the data access layer.

================================================================================================================================================================================================================================
What is stateless and stateful?

Stateless server doesn't maintain anything related to the user e.g. Take the example of a static files like css/JavaScript/images so when server serves these files it needn't to store whom these files are being served. I think you can assume CDN server to be stateless.
Stateful server maintains whom it serves e.g. If a user logged into the website then server maintained a unique identifier for this user so that it shall recognise ther user whenever there is next request from the user.

================================================================================================================================================================================================================================
Rest is stateful or stateless?

Stateless
================================================================================================================================================================================================================================
What is advantage of soap over rest

SOAP	REST
1)	SOAP is a protocol.	REST is an architectural style.
2)	SOAP stands for Simple Object Access Protocol.	REST stands for REpresentational State Transfer.
3)	SOAP can't use REST because it is a protocol.	REST can use SOAP web services because it is a concept and can use any protocol like HTTP, SOAP.
4)	SOAP uses services interfaces to expose the business logic.	REST uses URI to expose business logic.
5)	JAX-WS is the java API for SOAP web services.	JAX-RS is the java API for RESTful web services.
6)	SOAP defines standards to be strictly followed.	REST does not define too much standards like SOAP.
7)	SOAP requires more bandwidth and resource than REST.	REST requires less bandwidth and resource than SOAP.
8)	SOAP defines its own security.	RESTful web services inherits security measures from the underlying transport.
9)	SOAP permits XML data format only.	REST permits different data format such as Plain text, HTML, XML, JSON etc.
10)	SOAP is less preferred than REST.	REST more preferred than SOAP.


Benefits of REST Over SOAP
In addition to using HTTP for simplicity, REST offers a number of other benefits over SOAP:

REST allows a greater variety of data formats, whereas SOAP only allows XML.
Coupled with JSON (which typically works better with data and offers faster parsing), REST is generally considered easier to work with.
Thanks to JSON, REST offers better support for browser clients.
REST provides superior performance, particularly through caching for information that’s not altered and not dynamic.
It is the protocol used most often for major services such as Yahoo, Ebay, Amazon, and even Google.
REST is generally faster and uses less bandwidth. It’s also easier to integrate with existing websites with no need to refactor site infrastructure. This enables developers to work faster rather than spend time rewriting a site from scratch. Instead, they can simply add additional functionality.


Benefits of SOAP Over REST
Because you can achieve most outcomes using either protocol, it’s sometimes a matter of personal preference. However, there are some use cases that SOAP tends to be better-suited for. For instance, if you need more robust security, SOAP’s support for WS-Security can come in handy. It offers some additional assurances for data privacy and integrity. It also provides support for identity verification through intermediaries rather than just point-to-point, as provided by SSL (which is supported by both SOAP and REST).

Another advantage of SOAP is that it offers built-in retry logic to compensate for failed communications. REST, on the other hand, doesn’t have a built-in messaging system. If a communication fails, the client has to deal with it by retrying. There’s also no standard set of rules for REST. This means that both parties (the service and the consumer) need to understand both content and context.
================================================================================================================================================================================================================================
key difference between setter and constructor injection?

A class that takes a required dependency as a constructor argument can only be instantiated if that argument is provided (you should have a guard clause to make sure the argument is not null.) A constructor therefore enforces the dependency requirement whether or not you're using Spring, making it container-agnostic.

If you use setter injection, the setter may or may not be called, so the instance may never be provided with its dependency. The only way to force the setter to be called is using @Required or @Autowired , which is specific to Spring and is therefore not container-agnostic.

So to keep your code independent of Spring, use constructor arguments for injection.

We need the assurance from the IoC container that, before using any bean, the injection of necessary beans must be done.

In setter injection strategy, we trust the IoC container that it will first create the bean first but will do the injection right before using the bean using the setter methods. And the injection is done according to your configuration. If you somehow misses to specify any beans to inject in the configuration, the injection will not be done for those beans and your dependent bean will not function accordingly when it will be in use!

But in constructor injection strategy, container imposes (or must impose) to provide the dependencies properly while constructing the bean. This was addressed as " container-agnostic manner", as we are required to provide dependencies while creating the bean, thus making the visibility of dependency, independent of any IoC container.

================================================================================================================================================================================================================================
which is more secure soap or rest? why?
================================================================================================================================================================================================================================
What is design pattern and what is the advantage of using design pattern?
================================================================================================================================================================================================================================
What is hibernate caching and why is it needed?
================================================================================================================================================================================================================================
What is difference between @Restcontroller and @Controller annotations
================================================================================================================================================================================================================================
When do you use Interface in your application?
================================================================================================================================================================================================================================
Difference between jpa and hibernate?
================================================================================================================================================================================================================================
Difference between split and substring?
================================================================================================================================================================================================================================
s = india
s.substring (0,2) will it produce new string?
================================================================================================================================================================================================================================
How will you check if a string available in a huge file?
================================================================================================================================================================================================================================
Available methods in Object class?
================================================================================================================================================================================================================================
notify? notifyall?
================================================================================================================================================================================================================================
Synchronized method vs Synchronized block

The difference is in which lock is being acquired:

synchronized method acquires a lock on the whole object. This means no other thread can use any synchronized method in the whole object while the method is being run by one thread.

synchronized blocks acquires a lock in the object between parentheses after the synchronized keyword. Meaning no other thread can acquire a lock on the locked object until the synchronized block exits.

So if you want to lock the whole object, use a synchronized method. If you want to keep other parts of the object accessible to other threads, use synchronized block.

If you choose the locked object carefully, synchronized blocks will lead to less contention, because the whole object/class is not blocked.

This applies similarly to static methods: a synchronized static method will acquire a lock in the whole class object, while a synchronized block inside a static method will acquire a lock in the object between parentheses.

When you synchronize a method, you are effectively synchronizing to the object itself. In the case of a static method, you're synchronizing to the class of the object. So the following two pieces of code execute the same way:
================================================================================================================================================================================================================================
what is dispacher Servlet?
================================================================================================================================================================================================================================
servlet container has dependency injection?
================================================================================================================================================================================================================================
Why do we go for Factory pattern?
================================================================================================================================================================================================================================
Lazy loading in Hibernate?

A hibernare lazy load example will look like this:

@OneToMany( mappedBy = "category", fetch = FetchType.LAZY )
private Set<ProductEntity> products;
Another attribute parallel to "FetchType.LAZY" is "FetchType.EAGER" which is just opposite to LAZY i.e. it will load association entity as well when owner entity is fetched first time.

The default behavior is to load ‘property values eagerly’ and to load ‘collections lazily’. Contrary to what you might remember if you have used plain Hibernate 2 (mapping files) before, where all references (including collections) are loaded eagerly by default.
Also note that @OneToMany and @ManyToMany associations are defaulted to LAZY loading; and @OneToOne and @ManyToOne are defaulted to EAGER loading. This is important to remember to avoid any pitfall in future.
================================================================================================================================================================================================================================
Hibernate name query

Named queries in hibernate is a technique to group the HQL statements in single location, and lately refer them by some name whenever need to use them. It helps largely in code cleanup because these HQL statements are no longer scattered in whole code.

Apart from above, below are some minor advantages of named queries:

Fail fast: Their syntax is checked when the session factory is created, making the application fail fast in case of an error.
Reusable: They can be accessed and used from several places which increase re-usability.
DepartmentEntity.java
@Entity
@Table(name = "DEPARTMENT", uniqueConstraints = {
                    @UniqueConstraint(columnNames = "ID"),
                    @UniqueConstraint(columnNames = "NAME") })
@NamedQueries
(
    {
        @NamedQuery(name=DepartmentEntity.GET_DEPARTMENT_BY_ID, query=DepartmentEntity.GET_DEPARTMENT_BY_ID_QUERY),
        @NamedQuery(name=DepartmentEntity.UPDATE_DEPARTMENT_BY_ID, query=DepartmentEntity.UPDATE_DEPARTMENT_BY_ID_QUERY)
    }
)
public class DepartmentEntity implements Serializable {
     
    static final String GET_DEPARTMENT_BY_ID_QUERY = "from DepartmentEntity d where d.id = :id";
    public static final String GET_DEPARTMENT_BY_ID = "GET_DEPARTMENT_BY_ID";
     
    static final String UPDATE_DEPARTMENT_BY_ID_QUERY = "UPDATE DepartmentEntity d SET d.name=:name where d.id = :id";
    public static final String UPDATE_DEPARTMENT_BY_ID = "UPDATE_DEPARTMENT_BY_ID";
	
	-------------------------------------
	
	
	
	TestHibernateNamedQuery.java
public class TestHibernateNamedQuery
{
    public static void main(String[] args)
    {
        //Open the hibernate session
        Session session = HibernateUtil.getSessionFactory().openSession();
        session.beginTransaction();
        try
        {
            //Update record using named query
            Query query = session.getNamedQuery(DepartmentEntity.UPDATE_DEPARTMENT_BY_ID)
                                        .setInteger("id", 1)
                                        .setString("name", "Finance");
            query.executeUpdate();

================================================================================================================================================================================================================================
What are scopes and questions on it?
================================================================================================================================================================================================================================
What is a self join?
================================================================================================================================================================================================================================
Why Indexes are used?
================================================================================================================================================================================================================================
what are spring repositories?
================================================================================================================================================================================================================================
Hibernate Pagination?
================================================================================================================================================================================================================================
Wat is runnable and callable?
A Callable needs to implement call() method while a Runnable needs to implement run() method.
A Callable can return a value but a Runnable cannot.
A Callable can throw checked exception but a Runnable cannot.
A Callable can be used with ExecutorService#invokeXXX(Collection<? extends Callable<T>> tasks) methods but a Runnable cannot be.

public interface Runnable {
    void run();
}

public interface Callable<V> {
    V call() throws Exception;
}
================================================================================================================================================================================================================================
Wait and notify belong to which class?

to the object class
================================================================================================================================================================================================================================
List the Object class methods.?

Object as a Superclass
The Object class, in the java.lang package, sits at the top of the class hierarchy tree. Every class is a descendant, direct or indirect, of the Object class. Every class you use or write inherits the instance methods of Object. You need not use any of these methods, but, if you choose to do so, you may need to override them with code that is specific to your class. The methods inherited from Object that are discussed in this section are:

protected Object clone() throws CloneNotSupportedException
      Creates and returns a copy of this object.
public boolean equals(Object obj)
      Indicates whether some other object is "equal to" this one.
protected void finalize() throws Throwable
      Called by the garbage collector on an object when garbage
      collection determines that there are no more references to the object
public final Class getClass()
      Returns the runtime class of an object.
public int hashCode()
      Returns a hash code value for the object.
public String toString()
      Returns a string representation of the object.
The notify, notifyAll, and wait methods of Object all play a part in synchronizing the activities of independently running threads in a program, which is discussed in a later lesson and won't be covered here. There are five of these methods:

public final void notify()
public final void notifyAll()
public final void wait()
public final void wait(long timeout)
public final void wait(long timeout, int nanos)



================================================================================================================================================================================================================================
How to make a class immutable?
To create an immutable class in java, you have to do following steps.

- Declare the class as final so it can’t be extended.
- Make all fields private so that direct access is not allowed.
- Don’t provide setter methods for variables
- Make all mutable fields final so that it’s value can be assigned only once.
- Initialize all the fields via a constructor performing deep copy.
- Perform cloning of objects in the getter methods to return a copy rather than returning the actual object reference.
================================================================================================================================================================================================================================

Examples of immutable classes other than string?
Some famous immutable classes in the Standard API:

java.lang.String (already mentioned)
The wrapper classes for the primitive types: java.lang.Integer, java.lang.Byte, java.lang.Character, java.lang.Short, java.lang.Boolean, java.lang.Long, java.lang.Double, java.lang.Float
java.lang.StackTraceElement (used in building exception stacktraces)
Most enum classes are immutable, but this in fact depends on the concrete case. (Don't implement mutable enums, this will screw you up somewhen.) I think that at least all enum classes in the standard API are in fact immutable.

java.math.BigInteger and java.math.BigDecimal (at least objects of those classes themselves, subclasses could introduce mutability, though this is not a good idea)

java.io.File. Note that this represents an object external to the VM (a file on the local system), which may or may not exist, and has some methods modifying and querying the state of this external object. But the File object itself stays immutable. (All other classes in java.io are mutable.)

java.awt.Font - representing a font for drawing text on the screen (there may be some mutable subclasses, but this would certainly not be useful)

java.awt.BasicStroke - a helper object for drawing lines on graphic contexts
java.awt.Color - (at least objects of this class, some subclasses may be mutable or depending on some external factors (like system colors)), and most other implementations of java.awt.Paint like
java.awt.GradientPaint,
java.awt.LinearGradientPaint
java.awt.RadialGradientPaint,
(I'm not sure about java.awt.TexturePaint)
java.awt.Cursor - representing the bitmap for the mouse cursor (here too, some subclasses may be mutable or depending on outer factors)

java.util.Locale - representing a specific geographical, political, or cultural region.

java.util.UUID - a as much as possible globally unique identifier
while most collections are mutable, there are some wrapper methods in the java.util.Collections class, which return an unmodifiable view on a collection. If you pass them a collection not known anywhere, these are in fact immutable collections. Additionally, Collections.singletonMap(), .singletonList, .singleton return immutable one-element collections, and there are also immutable empty ones.

java.net.URL and java.net.URI - representing a resource (on the internet or somewhere else)

java.net.Inet4Address and java.net.Inet6Address, java.net.InetSocketAddress
most subclasses of java.security.Permission (representing permissions needed for some action or given to some code), but not java.security.PermissionCollection and subclasses.
All classes of java.time except DateTimeException are immutable. Most of the classes of the subpackages of java.time are immutable too.

================================================================================================================================================================================================================================

Java generics
Junit

Deloitte:
================================================================================================================================================================================================================================
what are the implicit objects in jsp?
1	request

This is the HttpServletRequest object associated with the request.

2	response

This is the HttpServletResponse object associated with the response to the client.

3	out

This is the PrintWriter object used to send output to the client.

4	session

This is the HttpSession object associated with the request.

5	application

This is the ServletContext object associated with the application context.

6	config

This is the ServletConfig object associated with the page.

7	pageContext

This encapsulates use of server-specific features like higher performance JspWriters.

8	page

This is simply a synonym for this, and is used to call the methods defined by the translated servlet class.

9	Exception

The Exception object allows the exception data to be accessed by designated JSP.
================================================================================================================================================================================================================================

by default what are variable types in Interface and why?
static and final

Interface variables are static because Java interfaces cannot be instantiated in their own right; the value of the variable must be assigned in a static context in which no instance exists. The final modifier ensures the value assigned to the interface variable is a true constant that cannot be re-assigned by program code.
================================================================================================================================================================================================================================

can a method be static and final?
yes. eg: main method
================================================================================================================================================================================================================================
Hibernate cache levels?

Hibernate provides 3 types of caching. 


1. Session Cache
    The session cache caches objects within the current session. It is enabled by default in Hibernate. Read more about  Session Cache . Objects in the session cache reside in the same memory location. 

2. Second Level Cache

     The second level cache is responsible for caching objects across sessions. When this is turned on, objects will first be searched in the cache and if they are not found, a database query will be fired. Read here on how to implement  Second Level Cache. Second level cache will be used when the objects are loaded using their primary key. This includes fetching of associations. Second level cache objects are constructed and reside in different memory locations. 

3. Query Cache

Query Cache is used to cache the results of a query. Read here on how to implement query cache. When the query cache is turned on, the results of the query are stored against the combination query and parameters. Every time the query is fired the cache manager  checks for the combination of parameters and query. If the results are found in the cache, they are returned, otherwise a database transaction is initiated.  As you can see, it is not a good idea to cache a query if it has a number of parameters, because then a single parameter can take a number of values. For each of these combinations the results are stored in the memory. This  can lead to extensive memory usage. 

================================================================================================================================================================================================================================
Ways to create string objects

Using new keyword
This is the common way to create a String object in java.

 
String str1= new String("Hello!");

Using character array
You could also convert character array into String here

 
char ch[]={ 'H','e','l','l','o','!',};
String str1=new String(ch);

Java String Class
Java String Class represents character strings. The java.lang.String class provides a lot of methods to work on string. Java String is not a primitive data type like int and long. It is basically an object that represents sequence of char values . It is like an array of characters works same as java string.
================================================================================================================================================================================================================================

When a string is created using new operator where will it get created?

first it checks if it exists in constant pool
in the Heap also it throws a copy in the constant pool
================================================================================================================================================================================================================================

Rules for using Interface
Methods inside Interface must not be static, final, native or strictfp.
All variables declared inside interface are implicitly public static final variables(constants).
All methods declared inside Java Interfaces are implicitly public and abstract, even if you don't use public or abstract keyword.
Interface can extend one or more other interface.
Interface cannot implement a class.
Interface can be nested inside another interface.

================================================================================================================================================================================================================================
What is intern function use
intern() method : In Java, when we perform any operation using intern() method, it returns a canonical representation for the string object. A pool is managed by String class.

When the intern() method is executed then it checks whether the String equals to this String Object is in the pool or not.
If it is available, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.
It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.
It is advised to use equals(), not ==, to compare two strings. This is because == operator compares memory locations, while equals() method compares the content stored in two objects.
================================================================================================================================================================================================================================
Junit test?
UI part?
================================================================================================================================================================================================================================
How to make class Singleton?

Singleton class means you can create only one object for the given class. You can create a singleton class by making its constructor as private, so that you can restrict the creation of the object. Provide a static method to get instance of the object, wherein you can handle the object creation inside the class only. In this example we are creating object by using static block.


Code:

package com.java2novice.algos;
 
public class MySingleton {
 
    private static MySingleton myObj;
     
    static{
        myObj = new MySingleton();
    }
     
    private MySingleton(){
     
    }
     
    public static MySingleton getInstance(){
        return myObj;
    }
     
    public void testMe(){
        System.out.println("Hey.... it is working!!!");
    }
     
    public static void main(String a[]){
        MySingleton ms = getInstance();
        ms.testMe();
    }
}

================================================================================================================================================================================================================================
final ArrayList<String> s = new ArrayList<String> (); --> is it a valid statement?
yes but you cannot reassign the reference variable s it throws exception
Exception in thread "main" java.lang.Error: Unresolved compilation problem: 
	The final local variable s cannot be assigned. It must be blank and not using a compound assignment

	at MainClass.main(MainClass.java:14)
	
================================================================================================================================================================================================================================
What's the difference between @Component, @Repository & @Service annotations in Spring?

@Controller

The @Controller annotation indicates that a particular class serves the role of a controller. The @Controller annotation acts as a stereotype for the annotated class, indicating its role.
What’s special about @Controller?
We cannot switch this annotation with any other like @Service or @Repository, even though they look same. The dispatcher scans the classes annotated with @Controller and detects @RequestMapping annotations within them. We can use @RequestMapping on/in only those classes annotated with @Controller.


@Service
@Service beans hold the business logic and call methods in the repository layer.
What’s special about @Service?
Apart from the fact that it's used to indicate, that it's holding the business logic, there’s nothing else noticeable in this annotation; but who knows, Spring may add some additional exceptional in future.


@Repository
This is to indicate that the class defines a data repository.
What’s special about @Repository?
In addition to pointing out, that this is an Annotation based Configuration, @Repository’s job is to catch platform specific exceptions and re-throw them as one of Spring’s unified unchecked exception. For this, we’re provided with PersistenceExceptionTranslationPostProcessor, that we are required to add in our Spring’s application context like this:

<bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/>
This bean post processor adds an advisor to any bean that’s annotated with @Repository so that any platform-specific exceptions are caught and then re-thrown as one of Spring’s unchecked data access exceptions.

================================================================================================================================================================================================================================
Difference between sleep and wait in threads

wait()
wait() method releases the lock.
wait() is the method of Object class.
wait() is the non-static method - public final void wait() throws InterruptedException { //...}
wait() should be notified by notify() or notifyAll() methods.
wait() method needs to be called from a loop in order to deal with false alarm.

wait() method must be called from synchronized context (i.e. synchronized method or block), otherwise it will throw IllegalMonitorStateException

sleep()
sleep() method doesn't release the lock.
sleep() is the method of java.lang.Thread class.
sleep() is the static method - public static void sleep(long millis, int nanos) throws InterruptedException { //... }
after the specified amount of time, sleep() is completed.
sleep() better not to call from loop(i.e. see code below).
sleep() may be called from anywhere. there is no specific requirement.


One key difference not yet mentioned is that while sleeping a Thread does not release the locks it holds, while waiting releases the lock on the object that wait() is called on.

synchronized(LOCK) {
    Thread.sleep(1000); // LOCK is held
}


synchronized(LOCK) {
    LOCK.wait(); // LOCK is not held
}

================================================================================================================================================================================================================================
why wait method need to called in synchronized block
Why wait(), notify(), notifyAll() must be called inside a synchronized method/block?
In Java, any object can act as a monitor - that's an entity with a single lock, an entry queue, and a waiting queue. An object's method without qualifed by the keyword synchronized  can be invoked by any number of  threads at any time, the lock is ignored. The synchronized method of an object, one and only one thread, who owns the lock of that object, can be permitted to run that method at any time;i.e. a synchronized method is mutually exclusive . If, at the time of invocation, another thread owns the lock, then the calling thread will be put in the Blocked state and is added to the entry queue.

The wait(), notify(), and notifyAll() methods should be called for an object only when the current thread has already locked the object's lock. This point sometimes goes unnoticed because programmers are used to calling these methods from within synchronized methods or blocks. Otherwise, you will get "java.lang.IllegalMonitorStateException: current thread not owner" at runtime.

When a thread running in a synchronized method of an object is calling the wait() method of the same object, that thread releases the lock of the object and is added to that object's waiting queue. As long as it's there, it sits idle. Note also that wait() forces the thread to release its lock. This means that it must own the lock of an object before calling the wait() method of that (same) object. Hence the thread must be in one of the object's synchronized methods or synchronized block before calling wait().

When a thread invokes an object's notify() or notifyAll() method, one (an arbitrary thread) or all of the threads in its waiting queue are removed from the waiting queue to the entry queue. They then actively contend for the object's lock, and the one that gets the lock goes on to execute. If no threads are waiting in the waiting queue, then notify() and notifyAll() have no effect. Before calling the notify() or notifyAll() method of an object, a thread must own the lock of the object. Hence it must be in one of the object's  synchronized methods or synchronized block.

A thread in the waiting queue of an object can run again only when some other thread calls the notify() (or the notifyAll) method of the same object.

The reason to call wait() is that the thread does not want to execute a block of code until a particular state to be achieved. It wants to wait until a particular state to be achieved. The reason to call notify() or notifyAll() method is that the thread will signal others that "a particular state has been achieved". The state is a communication channel between threads and it must be shared mutable state.

For example, one thread read data from a buffer and one thread write data into buffer. The reading data thread needs to wait until the writing data thread completly write a block data into the buffer. The wirting data thread needs to wait until the reading data thread completly read the data from the buffer. If wait(), notify(), and notifyAll() methods can be called by a ordinary method , the reading thread calls wait() and the thread is being added to waiting queue . At just the same moment, the writing thread calls notify() to signal the condition changes. The reading thread misses the change and waits forever. Hence, they must be called inside a synchronized method or block which is mutually exclusive.
================================================================================================================================================================================================================================

SOLID PRINCIPLES?
how spring mvc works interally?
@RequestMapping working?
What are functional interfaces? what are the benifits of the functional interfaces?
What are streams in java?
how spring boot does auto configuration?
how can we create multi data sources in spring boot?
Spring bean lifecycle


Starvation and Deadlock
in producer and consumer problem does dead lock occure?
When thread locks the object, where this information is stored in the java?

Thread pool
ThreadLocal
Thread executor service.
Thread factory
Thread session id
callable interface

difference between runnable and callable?

Benifits of stream api in java


POS
IOT
SDLC knowledge
